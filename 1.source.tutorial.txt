
Welcome to the fake.music and SnM blog.

What this blog is about
------------------------

I want to showcase and explain the fake.music project, and the SnM sound and music engine.

The fake.music project is a software project.  Its goal is to
	"Use non-musical processes to produce what sounds like music".

The SnM sound engine is a collection of ruby classes and utility functions.


Who might be interested?
-------------------------

Anyone who has checked out the fake.music albums (for example, on bandcamp: fakemusic2020.bandcamp.com ),
 and wants to know more about how the music is made.

Any ruby programmer who is interested in using the SnM sound engine to produce music.

Any developer who is writing their own sound engine, and are looking for ideas and techniques.

Any algorithmic composer who is looking for ideas and techniques.


How this blog will be structured
---------------------------------

I am going to present it as an instruction course, a set of tutorials.

I'll be introducing the capabilities in a systematic way, starting with how to produce sounds, and leading through
to some familiar musical concepts.  I'll also be showing you some of the tools SnM has for
facilitating algorithmic composition.

In the process, I will show how I am able to use the SnM sound and music engine to 
	"Use non-musical processes to produce what sounds like music"

I plan on producing one complete module per month, for six months.  At the end of each month, I plan to release
an album that uses the capabilities taught so far.

The albums (and modules) will be as follows:

1. "Source"		
	Continuous sources (drones).

2. "The Event"
	Sound events.  Introduction to melodies and scales

3. "Harmony"
	Introducing the harmonic series.  New sound possibilities, time signatures, musical sounding scales

4. "Nature"
	Introducing a simple rhythmic idea that mimics the sounds of nature.
	Reveal the power of the Speculate language, for specifying and generating SnM objects.

5. "Euclid"
	A way of generating rhythmic patterns that appear in music from cultures across the world.
	Introducing chords, Tempo and Swing



How to get the SnM sound engine.
--------------------------------

It is available as a tar.gz from the following link:  github.com/snm-sound-and-music/snm-fake-music
Click on the green "Code" button, and select Download ZIP.  Look inside the zip.


I only use GNU/linux.  Other operating systems are not supported.
The engine itself is just plain ruby, so it should work on any operating system, but I can't give you advice on that.

You need to be able to
	unpack a tar.gz file

		I use 
			tar -xf $tarfile

	run a ruby script

		I use
			ruby -I $loadPath $script

	create a ruby script

		I use
			vi $script

	convert a raw soundfile to other formats

		I use
			sox -r44100 -b 16 -e signed-integer -c2 -v$headroom $fromrawfile $towavfile
			(where headroom is the amount to decrease the volume of the raw sound file)

	(optional) play a raw soundfile

		I use
			play -r 44100 -b 16 -e signed-integer -c2  $rawfile


By default, SnM generates raw sound as 16 bit, signed integer on two channels with a sample rate of 44100,
so it's compatible with standard CD format.

By default, the soundfile is written to stdout.

I use 64 bit machines, so all the internal SnM calculations are 64 bit.
I don't do any post-production or editing of the soundfiles.  What comes out is what gets published.
Therefore, I don't need more than 16 bits in the output file, and I don't need a higher sample rate.  

If you want to change these defaults, look at the classes Output (and NormalisingOutput), and the class SampleRate.
Similarly, if you want to output some other soundfile format by default.

One final thing.

By default, the function soundfile() (described below), uses NormalisingOutput.  This class keeps the entire
 soundfile in memory, and when the soundfile is completed, it normalises the entire file to bring both channels
 to the range of -1.0 - 1.0.  It treats each channel independently, and it will increase or reduce all the values
 to fit the entire channel into the range -1.0 to 1.0.  THEN it writes the entire soundfile to a file.  The name
 of the file is derived from an environment variable, $outputFile. 

So you also need to be able to

	set an environment variable before you run the ruby script

	I use

		outputFile="MyMasterpiece.raw"
		export outputFile

	(or just edit the class NormalisingOutput and hard-code the name of the output file)



Module 1.  Source
=============================================================

The plan for this album is:

	About 40 minutes of sound. (Standard length for an LP record)
	Each track between 2-3 minutes long.
	Each track to be generated by the same script.
		(in other words, the script needs to create a different piece each time it is run)
	Only continuous sources to be used (no sound events)
	No integer arithmetic on frequencies or durations.
		This last constraint means that there will be no nice sounding harmonies, and no compound rhythms.

Let me show you how to do that..


Hello World.
-------------

Let's do a hello world example to get started.

The first line in any snm script is:

	load "snm"

This loads the entire SnM music engine and all its functionality.

The final line in any snm script is usually:

	soundfile( piece, pieceLen, fadeIn, fadeOut )

This generates the soundfile, and writes it to stdout.

	piece				is any SnM object that creates sound. (specifically, a subclass of Source)
	pieceLen 		is the total length of the soundfile in seconds
	fadeIn 			specifies a duration in seconds for a fade-in at the start
	fadeOut 			specifies a duration in seconds for a fade-out at the end

If piece ends by itself (some SnM objects do), then all you need is:

	soundfile( piece )


An example of something you could use as piece is:

	piece=PitchFlame.new

Therefore, the entire SnM hello world script would look like this:

	load "snm"
	piece=PitchFlame.new
	soundfile( piece, 6, 0.1, 2 ) 

This produces 6 seconds of something that might possibly sound a bit like a fire burning.

You can make this as long as you like, but the sound doesn't change, so it gets pretty boring pretty quickly.


How not to get a more interesting sound
----------------------------------------

Let's try and make it more interesting.

PitchFlame takes two optional arguments, a nominal pitch, and a raggedness >= 0.0.
For example:

	piece=PitchFlame.new( 125.0, 1.0 )


This changes the sound, but it still doesn't remain interesting for more than a few seconds.

I can get the script to choose some random values:

	piece=PitchFlame.new( 
		randomFreq( 200.0, 1280.0, "center=" ),
		randomFloat( 0.0, 3.0, "raggedness=" )
	 )

Some explanation:

	to get a random number, you need to specify the range, you want a random number between minValue and maxValue.

	for example

		randomFloat( 10.0, 20.0 )
		randomInteger( 3, 9 )

	When choosing a frequency (or pitch), randomFloat is usually not what you want.

	This is because of the way we hear pitch.  I won't go into it here, but one way to think about it
		is to look at all the notes on a piano, and look up the frequency of each note.  Then look at how
		those frequencies change as you go from octave to octave.  It's not a linear progression, it's logarithmic.

	This means that if you use randomFloat to choose a frequency, you will get lots of notes that sound high, and
		very few notes that sound low.

	Instead, use

		randomFreq( 40.0, 1280.0 )

	This will give you an even spread of notes at each octave.

	There is another random number function,

		randomHigh( 10.0, 100.0 )

	This is like the inverse of randomFreq.  It gives you a distribution that is highly biased to the larger values.
	Use it to get a frequency distribution, but you are working with a wavelength, rather than the frequency. (I know,
	it's not something you want very often, but sometimes it's exactly what you want).

	And finally, notice the third parameter.

	This is optional, and typically you would use a string here.
	If this parameter is present, SnM will "trace" the chosen value to stderr, and put this parameter at the start,
	so for example, 

		randomFreq( 200.0, 1280.0, "center=" )

	might result in

		center=890.6094279597004

	appearing in the log file (stderr).

	I find this capability very useful.  Because I like the script to make as many decisions as possible, this is the
		only way to know what values have been chosen.

	Furthermore, if the script by chance happens to come up with a sound that I like and want to re-use,
		it's useful if the logfile not only contains the values, but written it out in such a way that I can just
		cut and paste it straight back into another script.

	Like this:

		center=890.6094279597004					# from a logfile
		raggedness=1.8639497151216209				# from a logfile

		piece=PitchFlame.new( center, raggedness )


Well, you've learned some new stuff, but the sounds really aren't that interesting yet.  The problem is they
don't change enough.


What other sounds are available?



Oscillator
-----------

Yes, Oscillators.

By default, you get a sine-wave oscillator.  You need to specify the pitch separately. Here is a complete example:

	load "snm"

	osc=Oscillator.new
	osc.pitch=randomFreq( 40.0, 1280.0, "osc.pitch=" )

	piece=osc
	pieceLen=6
	fadeIn=0.1
	fadeOut=2

	soundfile( piece, pieceLen, fadeIn, fadeOut )

Notice the range of pitches I'm using.  fake.music project is using "non-musical processes". This means I'm not using
any music theory, and I'm not hard-coding any musical style hints.  One way for me to ensure that I don't
accidentally slip into "musical" territory is to avoid using numbers from music theory.

For example, if I say

	osc.pitch=440.0

this is obviously a musical value.  Every musician knows that this is concert A pitch.

On the other hand,

	osc.pitch=512

is not a musical value.  Every programmer knows that this is a power of 2.

So I avoid any values that clearly have a musical meaning.

But why 40.0 as the lowest pitch and 1280.0 as the highest?

Well, I arrived at this partly by trial and error.  I just tried various pitches to arrive at the sound range that
I considered to be comfortable.  Obviously, there's no point in using pitches that are outside the range of hearing,
and nor does it make sense to use pitches that are just plain painful or annoying to pets.

The lowest value (40.0) approximates the bottom note of a bass guitar.  It's just the easiest number to remember that is
close to that pitch.  If you keep doubling that value, you get octaves above that note.
So, 40, 80, 160, 320, 640, 1280.  That brings you to about the highest pitch you can get on a cutaway electric guitar.
40 to 1280.  A nice range that's easy to remember, and doesn't involve actual musical pitches.

Does using guitars as my example break the rule about non-musical processes?  Sue me.

Does a sine oscillator give you an interesting sound.  No.  Not at any pitch.


Shapes
-------

We can try different waveforms for the oscillator.  When you create an oscillator, you can give it a Shape as the
argument.

Some shapes:

	shape=Circle.new
	shape=SemiCircle.new
	shape=Quadrant.new
	shape=DownQuadrant.new

	shape=Sine.new				# this is the default for an Oscillator

	osc=Oscillator.new( shape )		# use the shape as the waveform of the oscillator

You can get a cheap ascii-art representation of a Shape using the asText() method:

	shape.asText( 40, 95 )

The ascii-art is written to stderr.  The shape is drawn sideways down the page. The first argument is the
number of rows to use, and the second argument is the number of columns.


We can also get the script to choose a shape from a list:

	shape=chooseFrom(
        Circle.new,
        SemiCircle.new,
        Quadrant.new,
        DownQuadrant.new,
        Sine.new
	 )

Or in ruby, you can even do

	shape=chooseFrom(
        Circle,
        SemiCircle,
        Quadrant,
        DownQuadrant,
        Sine
    ).new

Some of these shapes sound more or less pleasant, and some are horrible.  None are particularly interesting.


Here are some more shapes:

	shape=chooseFrom(
        Triangle.new( randomFloat( 0.0, 1.0, "apex=" ) ),
        Square.new( randomFloat( 0.0, 1.0, "switchPoint=" ) ),
        Zig.new( randomFloat( 0.0, 1.0, "hi=" ), randomFloat( 0.0, 1.0, "lo=" ) ),
        Zag.new( randomFloat( 0.0, 1.0, "hi=" ), randomFloat( 0.0, 1.0, "lo=" ) )
	 )

SnM has lots of Shapes. I'll show you more as we go on.

Two things about the previous example.

1. All the shapes are created before a choice is made. I don't really care about the inefficiency, but it clutters up the logfile with a whole lot of irrelevant output for each randomFloat.

2. You don't know what shape was chosen.


Here is a pattern I use a lot:

shapeType=chooseFrom(
        :circle, :semicircle, :quadrant, :downquadrant, :sine, :triangle, :square, :zig, :zag
 ).traceme( "shapeType=" )

shape=case shapeType
        when :circle
                Circle.new
        when :semicircle
                SemiCircle.new
        when :quadrant
                Quadrant.new
        when :downquadrant
                DownQuadrant.new
        when :sine
                Sine.new
        when :triangle
                Triangle.new( randomFloat( 0.0, 1.0, "apex=" ) )
        when :square
                Square.new( randomFloat( 0.0, 1.0, "switchPoint=" ) )
        when :zig
                Zig.new( randomFloat( 0.0, 1.0, "hi=" ), randomFloat( 0.0, 1.0, "lo=" ) )
        when :zag
                Zag.new( randomFloat( 0.0, 1.0, "hi=" ), randomFloat( 0.0, 1.0, "lo=" ) )
end


This solves both those issues.

	the traceme() method on the first line is implemented on Object, so it can be used anywhere.
	It traces the value, with the specified message, to the logfile (stderr), AND returns the value it was invoked on.

	So now we know what choice got made, because it was written to the logfile.

	The case statement means we only create the shape that got chosen.



Tracing in SnM
----------------

This might be boring to some people.  You can skip it if you want.

Right at the top of the SnM class hierarchy are two utility classes that have nothing to do with sound or music.
At the top is Textwise.

Textwise is a class that can produce text representations of arbitrary ruby objects.  Yes, I know, 
 ruby already does that. But this is closer to my personal requirements.

My requirements are:

1. If possible, the string produced must be exactly the same as the ruby code required to produce that object.

	For example, :symbol for a symbol, "string" for a string.
	This makes it easier for me to cut and paste from a log file into a script.

	This requirement is relaxed if I just want to trace a message.  In that case, quotes aren't required.
     The software can read my mind, so it knows when to do this.


2. It needs to be easy to parse (ie, read).  So an Array or a Hash needs to be indented in such a way that
		I can easily see the structure of any nested Arrays and/or Hashes within it.


The one and only subclass of Textwise is Tracer

Tracer is all about writing stuff to the logfile (stderr by default).

This class is really quite convoluted.  You don't need to worry about the details here.

The methods you need to know are

	trace( *objects )

		traces a number of objects, starting each one on a new line.

		This is implemented as a method on all SnM classes (except Textwise)
		It is also a stand-alone utility function, which means it can be used without an object.

		eg:

			osc.trace( "I am an oscillator", osc, "yes, I am" )

			trace( "this is an oscillator:", osc )

		Note that Textwise will not be able to produce a useful representation of osc, 
			just an internal reference that lets you know it's an Oscillator.


	traceme( message )

		implemented on Object.
		traces a representation of the object, with the message prepended.
		returns the object value


Tracing is also a useful debugging tool.  In particular, you can implement tracing in a class definition, and
 allow individual objects to turn the tracing on or off, for example

	In the class definition:

		..
		traceif( :foo, "foo is happening" )
		..

	In the script:

		osc.setTrace( :foo, true )

You can also switch ALL tracing on or off for an object:

		osc.tracing=false

When trace is called on an object, the logfile message will include some text that identifies the object,

	for example:

		#<Oscillator:0x00000002d2c678>

	You might have hundreds of oscillators in a large piece, so you can give individual objects their own name to 
		make it easier to find the ones you are interested in.

		osc=Oscillator.new
		osc.trace "hello"

		osc.me="Interesting oscillator"
		osc.trace "hello, my name just changed"

	results in:

		#<Oscillator:0x00000001f7da18>: hello
		Interesting oscillator: hello, my name just changed



When are we going to hear some interesting sounds?
---------------------------------------------------

Soon.

First, let me quickly show you two more things that won't work, then I'll put you out of your suspense.

Noize. This is a harsh sound.

	piece=Noize.new( shape, center, raggedness )

Noize is like an Oscillator, except that each cycle it changes frequency.

	shape is any shape that an Oscillator can use.
	center is the nominal pitch
	raggedness is a value around that pitch.
		by default, raggedness is expressed as a power of two, so 1.0 means an octave on either side of the center.



Mixer

	Mixer is pretty much what you'd expect.  It takes a collection of Sources, and averages the value from each.

	eg:

		mix=Mixer.new( osc0, osc1, osc2 )

	You can add and remove items from the mix:

		mix.add( osc3 )
		mix.remove( osc0 )



Why aren't any of these sounds interesting?

The reason is that none of them change.  After a few seconds your ear/brain figures that out, and loses interest.



Volume Envelopes
------------------

One way to make a sound more interesting is to apply a volume envelope.

First some background (sorry).

An Oscillator by default has a range between -1.0 and 1.0.  This is for driving a speaker.  -1.0 represents the
voltage required to pull the speaker all the way back, and 1.0 represents the voltage required to push the speaker
all the way forward.  By rapidly changing these voltage values, you get an audible sound.

The amplitude of an Oscillator effects the volume.  With an amplitude of 1.0, the oscillator varies between the
full range of -1.0 - 1.0.  With an amplitude of 0.5, it reduces to -0.5 - 0.5, and with an amplitude of 0.0, there is
silence.

Therefore the amplitude controls the volume.

All SnM sound sources have a control that represents amplitude.  eg

	osc.amp=0.5
	pitchFlame.amp=0.3

and so on.

The problem with this is that our ears don't hear volume in a linear fashion.  So if you try

	osc.amp=0.5 and then later change it to osc.amp=0.25, it doesn't sound like the volume is halving.
	The smaller amplitudes sound louder than you'd expect.

There is an alternative method you can use, called vol=

	osc.vol=0.5
	osc.vol=0.25

The methods vol=() and amp=() both adjust the same internal setting, and both have a range between 0.0 and 1.0,
 but vol uses values that sound closer to what your ears hear. 

Actually, it is quite valid to use amp or vol values greater than 1.0, but
 the final output needs to remain in the range -1.0 and 1.0 to avoid overflow errors in the soundfile.  
 NormalisingOutput will correct this, but I like to keep everything within the valid range so I can detect bugs.

That is just some background on volume in SnM.


One way you can effect the loudness of a source dynamically is to apply a volume envelope.  You take a source, 
 and an envelope, and you just multiply them together.

The envelope is an SnM source that has values > 0.0 .  The typical range is 0.0 - 1.0, or anywhere in between, 
  depending on what you want.

You multiply them using a Multiplier, which is just like a Mixer except that instead of averaging the output values,
 it multiplies them all together.  Multiplier has all the same methods as Mixer, and just like Mixer takes any 
 number of Sources.

For example:

	load "snm"

	osc=Oscillator.new
	osc.freq=256

	env=Oscillator.new
	env.minValue=0.0
	env.maxValue=1.0		# this is the default
	env.freq=8				# 8 cycles per second

	pulse=Multiplier.new( osc, env )

	soundfile( pulse, 10, 0.1, 2 )


Going back to the discussion above on the difference between amplitude and volume, Multiplier impacts the amplitude,
 so it won't sound linear.  With experience, you can compensate for that by adjusting the Shape of the envelope.  
(Somewhat tricky).  Later I will show you how to dynamically adjust the volume of a Source directly (rather than the
 amplitude).


Using a volume envelope immediately makes the sound more interesting, so you can now play it for a bit longer.

Then, if you start combining and nesting Mixer and Multiplier, you can get a wide variety of rich and interesting sounds.


I'll leave you to play about with that.  You are limited only by your imagination.



Let's make it a bit easier to code
-----------------------------------

It doesn't take long for this to get a bit tedious, so I'd like to show you something that makes it a bit easier.

SnM has a utility function that allows you to create an SnM object, and configure it, all in one go.

It is based on the Setable interface.

Setable is the third class in the SnM class hierarchy.

So it goes

	Textwise  >   Tracer  >  Setable  >  .. everything else ..

The class Setable implements what I call the Setable interface.

This interface allows for a binding between data and functionality, which is defined on a class-by-class basis, 
 and which respects the class inheritance.

I won't go into the details yet, but it's easy to use in practice.

Here is the utility function which leverages the Setable interface, and makes life easier:

	make( class, [ initialising arguments ], configuration.. )

This function will create an instance of the specified class, and do configuration on the new object.

For example:

	osc=make( Oscillator, [], :freq, 320.0 )

This is the same as

	osc=Oscillator.new()
	osc.freq=320.0

An example that uses the initialising arguments:

	mix=make( Mixer, [ osc0, osc1, osc2 ], :vol, 0.8 )


The first argument is the class

The second argument is an array that contains all the arguments for the new() method

The remainder of the arguments are key, value pairs.

Each key is a symbol (  eg, :freq ) which binds to some functionality for that class.
Each value is a single ruby object that is used by the functionality bound to that symbol.

For example, for Oscillator, the symbol :freq is bound to the method freq=(), and the value is used as the argument to that method.

So
		:freq, 320.0
results in
		freq=( 320.0 )
being called on the object that was just created.


Only the first argument is required, so 

	make( Oscillator ) 

is valid.


Here is a more elaborate example:


	mix=make(
		Mixer,
		[
			make( Oscillator, [ Triangle.new( 0.1 ) ], 	:pan, -0.5, :freq, 512.0, :vol, 0.5 ),
			make( Oscillator, [ Square.new( 0.5 )   ],	:pan, 0.0, :freq, 256.0, :amp, 0.8 ),
			make( Oscillator, [ Triangle.new( 0.1 ) ],	:pan, 0.5, :freq, 128.0, :vol, 1.0 ),
		],
		:vol, 0.9
	 )

Notice that the oscillators are anonymous, I didn't need to assign them to variables.

:pan binds to the method pan=()
panning is implemented by StereoSource ( which is pretty much all SnM sources ), and it effects where the sound
 is placed on the left channel/right channel spectrum.



The other way to make things easier to code is to create ad-hoc utility functions.  As a programmer you know this.

eg:

	def newosc( shape, freq )
		osc=Oscillator.new( shape )
		osc.freq=freq
		return osc
	end

	osc0=newosc( Sine.new, 128.0 )
	osc1=newosc( Circle.new, 256.0 )


Altering the Pitch
--------------------

Another way to make a sound more interesting is to vary its pitch.

PitchBend can be used to vary the pitch of any object that responds to the method pitch=().

For example, Oscillator, PitchFlame, Noize, Mixer, Multiplier and PitchBend all implement pitch=().

Here is an example (adds vibrato to an oscillator):

	make( 
		PitchBend,
		[
			make( Oscillator, [] ),
			make(
				Oscillator,
				[],
				:minValue, 0.0,
				:maxValue, 0.08,					# a bit more than a semitone
				:duration, 0.09,					# about 11 times a second
				:phaseOffset, 0.0					# starts at the base note
			),
			:factor
		],
		:pitch,	128.0
	 )

Another example:

	PitchBend.new( osc, pitchBendCtl, :factor )

The first argument is the input source that will have its pitch changed.
The second argument is `multiplier', the amount that the pitch is changed.  It can be a number or a Source.
The third argument is :multiplier or :factor.

	:multiplier means that the resulting pitch is
		pitch * multiplier

	:factor means that the resulting pitch is
		pitch * 2**multiplier


Factor means a power of 2
--------------------------

I did a University degree in Mathematics, but that was a long long time ago, and the details are a bit vague now.
I'm pretty sure factor is completely the wrong word for a number that is used like that.  Probably a better word
would have been exponent or power (of 2).  But the word "factor" is pretty much baked into the SnM code by now,
and I don't have a compelling reason to change it.  So just remember:

In SnM, whenever you see "factor" or Factor, it means a power of 2.

For example:
	result = 2 ** factor


Back to PitchBend
--------------------
The way PitchBend works is that at each `tick' (ie, for each sample written to the output soundfile), it recalculates 
a pitch and applies it to its input.

The calculation used is
	pitch * multiplier			for multiplierMode == :multiplier
	pitch * 2**multiplier		for multiplierMode == :factor

where `pitch' is the PitchBend's pitch.


Here are some setable keys for PitchBend..

	:pitch, 128.0							# sets the pitch
	:multiplier, 2.0						# use a number for the multiplier
	:multiplier, ctlOsc					# use a control source for the multiplier
	:multiplierMode, :multiplier		# sets the multiplier mode.  Can be :multiplier or :factor
	:input, osc								# sets the input

PitchBend also has the usual setable keys for a StereoSource.

	:vol, :amp, :pan



PitchBend usage cases
----------------------

When you are controlling the multiplier with a source, you should probably use multiplierMode of :factor.
The reason is that it will give you a more natural sounding bend, and it's easier to specify bends on either side
 of the pitch.

For example, lets say you want to bend an octave on either side of the base pitch.

Here is one way to specify that:

	:multiplierMode, :multiplier,
	:multiplier,
		make( 
			Oscillator, [],
			:minValue, 0.5,
			:maxValue, 2.0,
			:duration, 3.0			# seconds
		 )

 minValue of 0.5 gives you an octave below, maxValue of 2.0 gives you an octave above.  1.0 gives you the base pitch.
It should be obvious that this oscillator will spend most of its time above the base pitch,  Is that what you wanted?

Another way to do it:

	:multiplierMode, :factor,
	:multiplier,
		make( 
			Oscillator, [],
			:minValue, -1.0,
			:maxValue, 1.0,
			:duration, 3.0
		 )

 minValue of -1.0 results in 2**-1.0 = 0.5, which is an octave below, 
 maxValue of 1.0 results in 2**1.0 = 2.0, which gives you the octave above.  
 in between these values, 0.0 results in 2**0.0 = 1.0, which gives you the base pitch.

You can see that this oscillator gives you a symmetric spread of pitch bend centered around the base pitch.


You can apply a PitchBend to a Mixer (or a Multiplier).  The Mixer will then apply the same pitch to each of its
 inputs.

If you want each input to end up with a different pitch (but keeping the same intervals), you apply a separate 
PitchBend to each input.

Like this:

	make(
		PitchBend,
		[
			make( 
				Mixer,
				[
					make(	PitchBend, [ osc0, 1.0, :multiplier ] ),
					make(	PitchBend, [ osc1, 1.25, :multiplier ] ),				# major 3rd
					make(	PitchBend, [ osc2, 1.5, :multiplier ] ), 				# perfect 5th
					make(	PitchBend, [ osc3, 2.0, :multiplier ] )				# octave
				]
			 ),
			make( Oscillator, :minValue, -1.0, :maxValue, 1.0, :duration, 10.0 ),
			:factor
		],
		:pitch,  256.0
	 )

This results in a major chord that bends an octave on each side of the root note every 10 seconds.

Notice that I'm using :factor for the PitchBend on the Mixer, but I'm using :multiplier for the PitchBend on each oscillator.

When you're using a number for the multiplier, it doesn't make any difference whether you use a multiplierMode of :multiplier or :factor.  You just need to get the numbers right.  Because fake.music doesn't use music theory, I don't really care what the values are for a semitone or a minor 6th.  People who are knowledgable about tuning theory will recognise that 1.25 is not really the major 3rd you get on a piano, and nor does 1.5 give you an equal tempered perfect 5th.



More about Setable.  An Excursion
----------------------------------
I want to introduce you to RampStream, which is extremely useful when it comes to certain types of control (volume, panning, pitch, anything).

But to completely understand RampStream, you also need to know about Generators, and how the Setable interface deals with Generators.

So an excursion is in order.


Everything about the Setable interface hinges on a single method

	set( key, value, trigger )

	key is the key (for example :vol )
	value is the value to set (for example 0.7)
	trigger is a boolean, the default is false.

	if trigger is true, then set() will "trigger" the value, and the result is the actual value to use.

In SnM, whenever I talk about "triggering" a value, I mean the result of the Setable method

	valueOf( value )

This method does different things, depending on what type of object value is.

If value is a Source,

	valueOf( source ) returns  source.out, which is the current output value for source

If value is a Generator,

	valueOf( generator ) returns generator.nextValue, which just fetches the next value from the generator.

Otherwise,

	valueOf( object ) returns the object


You don't need to know this, but Setable also has a method 

	trigger( key, value, trigger )

This is just a wrapper for set(), except that the default for trigger is true.

So

	set( key, value )			is the same as			trigger( key, value, false )
	trigger( key, value )	is the same as			set( key, value, true )


In the make() utility function, all those key value pairs result in  set( key, value ) being called.

So

	make( Oscillator, [ ], :pitch, 256.0 )

actually does

	obj=Oscillator.new()
	obj.set( :pitch, 256.0 )

You can see now what I mean when I say that the Setable interface enables a binding between data (the keys and values)
 and functionality ( what happens when you do set( key, value ) on a Setable object ).

As a user, you won't ever need to use set() directly, but you need to understand that everywhere the Setable
 interface is used, under the hood it's using set().

You most definitely need to understand what valueOf() does, and when it kicks in.  Later in this tutorial, I'll 
 introduce you to cases where it does get used.


Generators
------------
A Generator is a class that implements the instance method  nextValue()

Some examples of Generators:

	x=RandomFloat.new( 20.0, 50.0 )

		x.nextValue() will return a random float between 20.0 and 50.0

		(also, because x is also a Setable,   x.valueOf( x ) will do x.nextValue()  )


Similarly,

	RandomFreq, RandomInteger, RandomHigh
		( corresponding to utility functions randomFreq(), randomInteger() and randomHigh() )


There are many Generator subclasses in SnM, I will introduce them at the appropriate moments.


RampStream
-----------

RampStream gives you a timeseries that continuously moves from one point to another, a bit like a stock market graph
 or similar.

A Ramp is like a slope that moves from a start value to an end value in a straight line. It has a startValue, an endValue and a duration (in seconds).

A RampStream is like a series (stream) of Ramps, where the end value of one ramp becomes the start value of the next
 one.

The RampStream is constrained to only use end-points within a specified range (minValue and maxValue ).

For example

	RampStream.new( 0.0, 1.0 )

Gives you continuous movement between 0.0 and 1.0, but kind of random in the sense that from time to time the slope will
 change.

You can specify the start value using startValue=(), or the Setable key :startValue.  If not specified, then
 it's just a random value between minValue and maxValue.

eg
	make(
		RampStream,
		[ 0.0, 1.0 ],
		:startValue,	0.5
	 )

RampStream uses a Generator to determine how long each Ramp lasts.  The generator needs to generate floats that
 give a duration in seconds.  The default is RandomFloat.new( 1.0, 3.0 ), which means a new Ramp is started every 1-3 seconds.

eg

	make(
		RampStream,
		[ 
			0.0, 
			1.0,
			make( RandomFreq, [ 0.1, 5.0 ] )			# new ramp every 0.1-5 seconds, but biased towards shorter durations.
		]
	 )

Finally, there is an argument (valueMode) that controls how the new end-points are chosen.  It can be :float or :freq.
 The default is :float, which means that each new endpoint is calculated using randomFloat( minValue, maxValue )

	make(
		RampStream,
		[ 
			0.1, 
			1.0,
			make( RandomFreq, [ 0.1, 5.0 ] ),
			:freq
		]
	 )


randomFreq between 0.0 and some other number
---------------------------------------------

Compare the last example to the previous example.  Notice that I've changed the minValue from 0.0 to 0.1.
I've done this because the valueMode is now :freq.

If you use randomFreq( min, max ), min cannot be negative, because internally it uses powers of 2, and there is no power of 2 that results in a negative value.

	There is no value x such that 2**x is negative.

But also, there is no value x such that 2**x is 0.0

So from a theoretical point of view, randomFreq( 0.0, max ) is illegal.

You can compensate for that by choosing a number arbitrarily close to 0.0 (and if you specify randomFreq( 0.0, max ),
 the function will just substitute a very small number instead of 0.0 ).  The problem is that there is no obvious
 way to determine what small number should be used.  

If you have a mathematical mind, you see this by example.
Let's try some different substitutions and see what happens.

What I want:

	randomFreq( 0.0, 1.0 )

Let's try

	randomFreq( 0.5, 1.0 )		100% chance of choosing a value between 0.5 and 1.0

	randomFreq( 0.25, 1.0 )		50% chance of choosing a value between 0.5 and 1.0

	randomFreq( 0.125, 1.0 )	30% chance of choosing a value between 0.5 and 1.0

	randomFreq( 0.065, 1.0 )	25% chance of choosing a value between 0.5 and 1.0

So you can see that the choice of small number has a big impact on the distribution of numbers.
There is no obvious correct answer.

My advice, avoid using 0.0 as the min value and instead select a value that gives you the distribution you want.


RampStream as a control
------------------------

I think of RampStream as an easy way to get subtle continuous change.

The default duration generator RandomFloat.new( 1.0, 3.0 ) gives a moderately slow (but noticeable) rate of change.

Appropriate selection of minValue and maxValue gives you the amount of change.

For example

	make(
		Multiplier,
		[
			osc,
			make( RampStream, [ 0.5, 1.0 ] )
		]
	 )

results in an oscillator that gradually and continuously changes in volume.  The volume changes between 0.5 and 1.0.
If I want a more dramatic change, I could use

	make( RampStream, [ 0.0, 1.0, make( RandomFreq( 0.1, 1.0 ) ] )

so the volume now changes more rapidly, changes direction more frequently, and can go down to 0.0 .


If you do something like

	make(
		Mixer,
		[
			make( Multiplier, [ osc0, make( RampStream, [ 0.0, 1.0 ] ) ]  ),
			make( Multiplier, [ osc1, make( RampStream, [ 0.0, 1.0 ] ) ]  ),
			make( Multiplier, [ osc2, make( RampStream, [ 0.0, 1.0 ] ) ]  )
		]
	 )

you get a mix of oscillators, but because the volumes are constantly changing on all the oscillators, the
 result is a sound texture that constantly changes.


If all the oscillators have the same pitch, but a different shape, then you get a pitched tone that constantly
 changes in timbre.

You could use Oscillators instead of RampStreams, in which case you end up with a different style of timbre change.


RampStream is a Source, which means that you can use it as a sound source.  The trouble is that it changes too slowly
 for the ear to hear it as an audible sound.

But you can adjust the rate of change, right?

What happens if I do

	sound=RampStream.new( -1.0, 1.0, RandomFloat.new( 0.001, 0.01 ) )

Well, I get a PitchFlame.  PitchFlame is just a wrapper for RampStream.




Tickable
----------

You can now change volume (Multiplier) and pitch (PitchBend), 
	you can change it randomly (RampStream) or as a pulse (Oscillator),
	and you can mix and match using Mixer.

But SnM allows you to control any Setable setting on any Source, using any other source.

First, let me explain Tickable.

I think of SnM as working like a mechanical clock.  You have a central mechanism that provides both a source of energy,
 as well as a constant "tick".  Every other part of the clock is connected to the "ticker" by means of cogs, belts, rods and other mechanisms.

SnM has a similar concept.  When you invoke soundfile(), this sets up a NormalisingOutput, which is connected to the input.  The input in turn is connected to everything that makes up its input, and so on.  NormalisingOutput then provides the "ticks", and the connections transmits each tick through to all the other components.  

Each "tick" results in a single sample being written to the soundfile (stdout).  (44100 samples per second, two channels).  The purpose of the tick is so each component can do all the calculations and so forth required for the next sample.

Most of the time, the appropriate connections are made automatically, and usually they are what you want.  There are
 occasions where you need to disable the connection for individual components, and there are occasions where a component needs to "autoTick" if it's not connected to anything else.  More on that later.

The thing to understand at this point, is that everything that contributes to the final sound gets "ticked".

The class Tickable implements tick()

The class inheritance is like this:

	Textwise > Tracer > Setable > .. > Tickable > Source > StereoSource
		and
	Textwise > Tracer > Setable > .. > Tickable > Shape

It's not obvious why Shape should be Tickable, but after 4 or so years of working with the SnM framework, I finally
 realised that life is easier if it is.


ctl
-------

Each Tickable object has an internal variable called @ctl.  @ctl is a Hash.  It's keys are Setable keys (eg, :pitch),
 and the values are ruby objects - usually Sources

You can access @ctl using methods ctl() and ctl=().

Every tick, the object goes to each entry in the @ctl Hash, and for each key and value does

	trigger( key, value )

This mechanism means that any Setable key in a Tickable object can be re-calculated at every tick.  

Keep in mind that trigger() uses valueOf(). Just saying.

Ruby has some nice syntactic sugar around method calls and so forth.  So the following syntax can be used:

	obj.ctl[ :pitch ]=osc

		is syntactic sugar for:

	obj.ctl().[]=( :pitch, osc )

		the method .ctl() returns the Hash @ctl.
		the method .[]=( key, value )  (yes, that really is the method name) is implemented by Hash


The setable interface also allows you to set up a ctl:

	:ctl,	[ key, control ]


eg:

	make(
		Oscillator,
		[],
		:ctl, [ :vol,
						make( Oscillator, [], :minValue, 0.0, :duration, 0.1 )
				]
	 )

results in an Oscillator with tremolo.

The above example is somewhat similar to using Multiplier, except that (as I mentioned earlier), 
 Multiplier is like controlling :amp, whereas this example is controlling :vol


Near the end of this module, I will give a reference summary of all the various SnM classes and the setable keys
 you might be interested in.  This will give you ideas for what you might want to control.



CrossFader
-----------

A CrossFader takes two inputs and does crossfade on them.

The crossfader can be a float, but more likely it will be a Source.  Legal values are between 0.0 and 1.0.

When the crossfader is 0.0, the second input is at full volume and the first input is silent.
When the crossfader is 1.0, the first input is at full volume and the second input is silent.
Otherwise, the sound is a mix of the first and second input.

example

make(
	CrossFader,
	[
		osc0,
		osc1,
		make( Oscillator, [], :minValue, 0.0, :duration, 0.3 )
	]
 )


CrossOverStream
--------------

I think of a CrossOverStream like a movie where you have a sequence of scenes, and each scene cross-fades
 to the next.

The CrossOverStream takes three arguments.

	1. a Generator that generates sound sources
	2. a float or a Generator that specifies the "alone" duration, which is how long the current source plays on its own
	3. a float or a Generator that specifies the "crossfade" duration, which is how long it takes for the next source
			to cross-fade in to full volume.

Example

make(
	CrossOverStream,
	[
		make( NewFromList, [ [osc0, osc1, osc3] ] ),			# choose from a list of sources: [osc0, osc1, osc3]
		make( RandomFloat, [ 1.0, 3.0 ] ),						# random alone duration
		2.0																# always the same crossfade duration
	]
 )

Generator types that you could use for the sound source

	NewFromList
		select from a list of sources, but don't choose the same source twice in a row

		the argument is an array.
		eg
			NewFromList.new( [osc0, osc1, osc3] )


	NewFromWeightedList
		select from a weighted list of sources, but don't choose the same source twice in a row

		two arguments, an array of choices and an array of weights
		eg
			make( 
				NewFromWeightedList, 
				[ 
					[osc0, osc1, osc3], 
					[ 4,   2,    0.5 ] 
				]
			 )

		the weights determine the relative probability of selecting each value.  A weight of 0.0 means that choice
			will never get chosen.


	SequenceGenerator
		a sequence of values.  When the sequence gets to the end, it starts again from the beginning

		eg
			make( SequenceGenerator, [ [osc0, osc1, osc3] ] )


There are also Generators  FromList and FromWeightedList.  Don't use these for CrossOverStream.  You can't have the
 same source as both the current source and the incoming source.  This is because CrossOverStream ticks both sources,
 and if you have the same source twice, then it will get ticked twice.  This will cause the source to progress at 
 twice the speed, and sound an octave higher. (But only whilst the cross-fade lasts.  Then it will return to normal
 speed and pitch.  I'm sure that is not what you want!)


Or, you can get the durations from a Source:

	You could use a Source, like a RampStream or an Oscillator to specify the alone and crossfade durations.
   	Each time a new duration is required, it will use the current output value of the source.
   	Because the source is not connected for ticking, you would have to specify    :autoTick, nil  on the source

  eg
	make(
		CrossOverStream,
		[
			make( NewFromList, [ [osc0, osc1, osc3] ] ),

			# alone durations from an Oscillator
			make( 
				Oscillator,
				[],
				:autoTick, nil,				# any value will do. it's ignored
				:minValue, 1.0,
				:maxValue, 5.0,
				:duration, 15.0,
			 )

			# crossfade durations from a RampStream
			make(
				RampStream,
				[
					1.0, 5.0
				],
				:autoTick
			 )
		]
	 )

:autoTick ignores its argument, so you can put any value there.  Because of how make() is implemented, if the
 final value is missing (there's a key, but no value), then ruby will substitute nil as the value.
That's fine for :autoTick.




ClippedOscillator
-----------------

ClippedOscillator is like an Oscillator where clipping occurs at the high and low values.  The clipping creates
 distortion in the sound.

You specify a center and a range.

You can also specify a clipMin and clipMax.  By default clipMin=minValue (-1.0 by default ) and 
	clipMax=maxValue (1.0 by default )

The oscillator oscillates around the center, and extends by range on either side of the center.
Whenever the oscillator value exceeds clipMin or clipMax, the output will get clipped to that value.

I'm not sure how to explain it better.  ClippedOscillator is kind of experimental because it's a bit confusing to
 use, and there might be a better way to do it.  Functionally, it works fine.  It's just confusing to understand
 the details.

The result is a distorted Oscillator (depending on the shape and the values of center, range, minValue and maxValue).
The only shape that won't ever distort is Square, because it's already clipped.

You can also specify a mode, which determines how the range is applied to the center:

      case @mode
         when :add
            @minValue=@center-@range
            @maxValue=@center+@range
         when :multiply
            @minValue=@center/@range
            @maxValue=@center*@range
         when :factor
            @minValue=@center/2**@range
            @maxValue=@center*2**@range
      end

The default mode is :add


example of a sine oscillator with no clipping (because minValue==clipMin and maxValue==clipMax)

	make(
		ClippedOscillator,
		[
			# these are the defaults:
			Sine.new,
			0.0,
			1.0,
			:add
		],
		:clipMin,	-1.0,
		:clipMax,	1.0
	 )


example with occasional distortion caused by clipping

	make(
		ClippedOscillator,
		[ ],
		:ctl,
			[ :center,
					make( RampStream, [ -0.3, 0.3 ] )
			],
		:ctl,
			[ :range,
					make( RampStream, [ 0.7, 1.3 ] )
			]
	 )


Filters
---------
SnM implements a simple LoPassFilter, and a simple HiPassFilter

eg

	make(
		LoPassFilter,
		[
			inputSource,
			256.0
		]
	 )

	frequencies less than 256.0 will be passed through, frequencies more than 256.0 will be attenuated.

similarly

	make(
		HiPassFilter,
		[
			inputSource,
			128.0
		]
	 )

Cut out high and low frequencies, leave only the middle
	
	bandpass=make(
		LoPassFilter,
		[
			make(
				HiPassFilter,
				[
					inputSource,
					128.0
				]
			 ),
			256.0
		]
	 )


creating distortion using Mix
------------------------------

You already know about Multiplier and Mixer.

Multiplier takes a collection of sources, and multiplies their output values together.
Mixer takes a collection of sources, and outputs the average of their output values.

There is also Adder, which takes a collection of sources, and adds their output values together.

Adder is not very useful for combining sound sources, because as soon as you have more than one input source, 
 the resulting output is larger than the legal values.  (Output should be between -1.0 and 1.0)

There is also Mix.

Mix takes a collection of sources, and adds their output values together.  It then adjusts this value to force it
 to fit to the legal range of -1.0 and 1.0.

Mix has a parameter called ceiling.  It needs to be between 0.0 and 0.5. (But not 0.0).  The default is a random value between 0.1 and 0.3 because why not?

After adding all the output values, Mix looks at the absolute value of that number.
If it's between 0.0 and 1.0, then it adjusts the value so it's between 0.0 and 1.0-ceiling. (or 0.0 and -1.0+ceiling for -ve values)
If it's between 1.0 and 2.0, then it adjusts the value so it's between 1.0-ceiling and 1.0-ceiling*ceiling
If it's between 2.0 and 3.0, then it adjusts the value so it's between 1.0-ceiling*ceiling and 1.0-ceiling*ceiling*ceiling
.. and so on.

It doesn't matter how large the value gets, Mix will always adjust it so it's within the legal range of -1.0 and 1.0.

The adjustment distorts the mix, but it does it smoothly.  If ceiling is close to 0.5, the distortion is not so noticable,  But if it's close to 0.0, it's very noticable.  If the output from all the sources is between -1.0 and 1.0, then there is no distortion at all, it's just quieter.


Mix has some nice properties that come in useful when you are dealing with sound events, but at the moment, it's only
 useful for creating distortion.

In fact, you can distort a single sound source by making the volume (or amp) greater than 1.0.

For example:

	make(
		Mix,
		[
			make( 
				Oscillator, 
				[], 
				:freq, 128.0, 
				:ctl, 
					[:vol,
						make( Oscillator, [], :minValue, 0.6, :maxValue, 3.0, :duration, 5 )
					]
			 )
		],
		:ceiling,	randomFloat( 0.3, 0.1 )
	 )



Control of Shapes
-------------------
As I mentioned earlier, Shape is a subclass of Tickable.  That means the Shape implements ctl().

Each subclass of Shape has a different set of Setable keys that can be controlled.  Some shapes have no keys
 (for example, Sine, Circle, SemiCircle, Quadrant, DownQuadrant), those shapes never change.

Others have specific keys.

for example:

	Square			:switchPoint	(0.0-1.0)
	Triangle			:apex				(0.0-1.0)

You can set a control on these keys, for example

	make( Triangle, [], :ctl, [:apex, make( Oscillator, [], :minValue, 0.0, :duration, 1.0 ) ] )


If you then use that shape in an Oscillator, the Oscillator can tick the shape.

	make(
		Oscillator,
		[
			make( Triangle, [], :ctl, [:apex, make( Oscillator, [], :minValue, 0.0, :duration, 1.0 ) ] )
		],
		:tickShape,		true,
		:freq, 			128.0
	 )

Note that I set 

	:tickShape,    true 

 on the Oscillator. By default this setting is false.


You can always use the same shape in many Oscillators:

	shape=make( Triangle, [], :ctl, [:apex, make( Oscillator, [], :minValue, 0.0, :duration, 1.0 ) ] )

	osc0=make( Oscillator, [ shape ], :tickShape, true, :freq, 128.0 ) )
	osc1=make( Oscillator, [ shape ], :freq, 256.0 ) )
	osc2=make( Oscillator, [ shape ], :freq, 512.0 ) )

but only one should tick the shape.  Double ticking is almost never correct.

The other way to do it is to make the shape autoTicking, meaning that it (magically) ticks itself.

eg:

	shape=make( 
		Triangle, 
		[], 
		:ctl, 		[:apex, make( Oscillator, [], :minValue, 0.0, :duration, 1.0 ) ],
		:autoTick,	nil
	 )

	osc0=make( Oscillator, [ shape ], :freq, 128.0 ) )
	osc1=make( Oscillator, [ shape ], :freq, 256.0 ) )
	osc2=make( Oscillator, [ shape ], :freq, 512.0 ) )


The setable key :autoTick ignores it's value, so you can pass nil.

The way ruby works, and the way make() works, if you don't give a value to the last setable key, ruby will 
 substitute nil as the value.
So the following will also work (but only because :autoTick is the last key specified)

	shape=make( 
		Triangle, 
		[], 
		:ctl, 		[:apex, make( Oscillator, [], :minValue, 0.0, :duration, 1.0 ) ],
		:autoTick
	 )

Any Tickable object can be made to autoTick, but it's rarely the correct thing to do, because SnM tends to set up 
 appropriate ticking by default.



Rate of Change, Structure
--------------------------

We've looked at controlling volume using Multiplier, controlling pitch using PitchBend, and controlling
 any Setable parameter using ctl[ key ]=control  or :ctl, [ key, control ]

I want to talk about rate of change.

Remember at the start of this tutorial, where I showed how sounds that don't change are boring, so you get tired
 of them very quickly.  The solution was to construct sounds that changed.  This is where Multiplier, PitchBend and
 ctl comes in useful.

Now we have sounds that change, but how interesting are the sounds, and how long can you listen to it before it 
 becomes boring?

The answer to that is complex, but part of the answer is to look at the rate of change.

Let's assume that you are using an Oscillator to control some parameter.  Then the rate of change is the frequency 
of the control Oscillator.

Let's assume we are controlling volume.

If the frequency of the Oscillator is

	2 - 30 (say), then we have tremolo

If the duration of the Oscillator (which is 1.0/frequency) is (say)

	0.1 - 0.3, then we have a steady pulse, like a beat

A longer duration of 0.3 - 2.0 seconds is a slow pulse, similar to a bar-length in normal music.
Longer durations give you the length of a phrase, or the length of a segment or a section in music.

At the other end of the spectrum, 
	a frequency of 20 - 40 produces something like a rattle, especially if you use a shape like Triangle.new( 0.1 )

And a frequency in the audible range produces a strange sound effect, which is sometimes called resonance, or
 AM modulation (if you're controlling volume)


So the frequency/duration of the Oscillator does two things:

	1.  determines the nature of the effect.  It might create a sound effect like resonance or tremolo, a pulse of a certain speed, or a structural effect like a slow rise and fall in volume.

	2.  determines the rate of change.  This effects how long you can listen to the sound before it becomes "boring".


When the rate of change falls below 1 cycle per second (at which point, you would tend to specify it as :duration rather than :pitch or :freq), then it becomes what I think of as "structural".  At that point it begins to change how long the
sound will REMAIN interesting, because there is always "something" happening.  A fast rate of change makes the sound interesting in the short term, but boring in the long term.  A slow rate of change makes it boring in the short term, but perhaps interesting in the long term.

If you combine a number of controls, each with a different rate of change, this can result in a sound that is constantly changing in different ways at different rates of change.  The resulting sound will remain interesting for much longer, because the ear/mind is always hearing something that is new and different.

There is no science in what I'm saying.  I'm just pointing out that the way to make a continuous drone (which is what I'm doing in this first tutorial) is to consider the rate of change, and to provide a mixture of controls at different rates of change.

The effect that different rates of change will have in making a sound remain interesting (or not) is hard to predict, because the interactions between different rates of change can behave rather strangely.

One strategy is to select rates of change from a "spectrum", where each new duration is maybe 3-4 times the previous one.  For example, 1 second, 4, 15, 40 seconds.

If you make them all integer multiples of each other, the result is a predictable rhythmic structure.  For some reason, the mind is comfortable with repeating rhythms and can listen to them without getting bored.

I am avoiding that in this album, so I need to generate more change to compensate.

Even without using integer multiples, I can use different controls that use the same rate of change.  This results in a complex change that repeats at predictable intervals.

If you use two rates of change that are very close to each other (eg, 3 seconds and 3.1 seconds), it creates an "interference pattern" which adds an additional rate of change that is longer than either of the original rates of change, thus retaining interest longer.



phaseOffset
------------
Phase offset is one of the settings on an Oscillator.  It controls where in the shape the oscillator starts.
The legal values are between 0.0 and 1.0.   An obvious default value is 0.0, but after a few years of experience, I
have realised that a random value is a better choice.  Thus, by default, an Oscillator has a random phase offset.

The access method is phaseOffset=( value ), the Setable key is :phaseOffset.

Phase offset is an unusual setting.  For a single oscillator, the value of the phase offset makes no difference whatsoever.  You can play the same oscillator with different phase offsets and ear is physically unable to hear any difference.

However, phase offset is useful, and here is why:



1. If you play two or more oscillators together, with the same shape and the same pitch, but different phase offsets,
then the resulting sound is a single sound of the same pitch but a different waveform (shape).

To see this, take some graph paper, and draw a square wave pattern for a couple of cycles.
Below this, draw another square wave pattern of the same wavelength, but starting a quarter of a cycle later.

Below that, draw a third graph, which is the average of the first two.
The result is a pattern with the same wavelength, but an obviously different shape.

Thus the ear will hear not two (or more) oscillators, but a single tone, with a different timbre.

If you then change the volumes on each of the oscillators (using RampStream for example), then you will get a single tone at the same frequency, but changing in timbre.

Also notice that for some shapes, and some values of phaseOffset, the result is absolute silence.  For example,
two Oscillators with Sine as the shape, the same pitch, and phaseOffset 0.5 apart.  Ditto, using the shapes Square.new( 0.5 ), or Triangle.new( 0.5 ).



2. If you put a fast control on phase offset, you get an effect that sounds a little bit like vibrato.

This will work with a single oscillator so long as the frequency is not too slow.  Try a frequency in the range 5.0 to 10.0 to start with.  Too slow and you won't hear anything change.

The reason it sounds a bit like vibrato is that it creates a kind of doppler effect.  To my ear it sounds softer and sweeter than vibrato.



3.  If you are mixing a large number of oscillators together, you need to randomise the phase offsets.

For example, you can model white or pink noise by mixing a large number of sine oscillators together (and using a formula to determine the frequency of each oscillator).  I'm talking 30 or more oscillators at least.

If they all have the same phase offset, then at the start the mix will produce a strange "wobble" effect.  This is caused by a complex interference pattern that only happens at the beginning, and soon collapses into noise.

The way to prevent this strange effect at the start is to give each oscillator a random value for the phase offset.



4. If you are using an Oscillator as a control, and the duration is more than a couple of seconds, then the phase offset will be noticeable at the start of the piece.

Therefore, if you have a script that you want to run multiple times, but you don't want it to sound the same every time, you should randomise the phase offset, so the control doesn't always start in the same way.  Fortunately, that's the default behaviour for phaseOffset, so maybe I should have said if you DO want it to start the same way every time, you should manually set the phaseOffset to a specific value.



Glitches
---------

If the output volume changes suddenly, it will cause an audible glitch, which some people like but I don't.

If I hear a glitch, I regard it as a bug, and fix it immediately before I continue developing my script.
The reason for fixing it immediately is that often the solution is structural, meaning the script may need to
 be rewritten.  Further development could be a waste of time if you don't fix the glitch straight away.

With your current knowledge of SnM, the only way you can get a glitch is if you apply a Pulse envelope
 (either using Multiplier or using ctl[ :amp ] or ctl[ :vol ]), where you are using an Oscillator as the envelope,
 and the envelope shape has a sudden shift in value.

These envelope shapes will give you glitches if you use them as volume envelopes:

	Square
	Quadrant
	DownQuadrant
	Triangle( 0.0 )
	Triangle( 1.0 )

	.. and maybe others.

	Sometimes it depends on the parameters used, and it is also dependent on the duration of the pulse.
	Faster pulses will give more sudden volume changes.

You can also get a glitch if you have zero length fade-in or fade-out, and your are using a continous source
 as your piece:

	soundfile( osc, 5.0, 0.0, 0.0 )		# zero length fade-in and fade-out

		.. will have ugly glitches at the start and end.



More about Controls
--------------------

I want to end by saying some things about controls.  These are the Sources that are used to control
 Setable keys like :pitch, :vol, etc, or use as envelopes with Multiplier or PitchBend.

1. If it's an Oscillator, then the shape makes a difference to the final result.  Kinda obvious, but you might
 be surprised at how much of a difference it can be.

2. You can combine controls to get more complex control

eg

make(
	Multiplier,
	[
		osc,
		make(
			Adder,
			[
				make( RampStream, [ 0.0, 0.7 ] ),
				make( Oscillator, [], :minValue, 0.0, :maxValue, 0.3, :freq, 12 )
			]
		 )
	]
 )

gives an oscillator with tremolo (Oscillator), which changes in volume (RampStream).
The depth of the tremolo will appear to change, and will get larger as the volume decreases.

Note that I'm using an Adder, and I've adjusted the minValue and maxValue on both controls so that
 the values of both controls never exceed the legal range of 0.0 - 1.0 when added together.

	0.0 + 0.0 = 0.0		the extreme when both controls are at their minValue
	0.7 + 0.3 = 1.0		the extreme when both controls are at their maxValue



make(
	Multiplier,
	[
		osc,
		make(
			Multiplier,
			[
				make( RampStream, [ 0.0, 1.0 ] ),
				make( Oscillator, [], :minValue, 0.0, :maxValue, 1.0, :freq, 12 )
			]
		 )
	]
 )

gives an oscillator with tremolo (Oscillator), which changes in volume (RampStream).
The depth of the tremolo will remain constant, at full depth.


3. You can control the control

eg
	make(
		Oscillator,
		[ ],
		:ctl,
			[:vol,
				make( 
					Oscillator,
					[],
					:ctl,
						[:freq,
							make( Oscillator, [], :minValue, 2, :maxValue, 20, :duration, 10.0 )
						],
					:ctl,
						[:minValue,
							make( Oscillator, [], :minValue, 0.0, :maxValue, 1.0, :duration, 3.0 )
						]
				 )
			]
	 )

this is an oscillator with tremolo.
The tremolo changes in speed ( :ctl, [:freq, ... ] )
and depth ( :ctl, [:minValue, ... ] )


4. Rate of change richness

By having all these Sources involved in building up complex controls, you have an opportunity to make the
 sound remain interesting for longer by choosing different rates of change for each of the controlling Sources.


5. What to control

Here are the things I might typically control on an Oscillator sound source:

	:vol or :amp							only do one.  they both end up controlling the same internal setting
	:pitch, :freq or :duration			only do one.  they all end up controlling the same internal setting
	:multiplier
	:pan
	:phaseOffset

	shape					# the control keys available depend on the type of shape


On a Mixer, Adder, Multiplier or Mix:

	:vol or :amp
	:pan
	:pitch					# :freq is not implemented.  don't use :duration

Additionally, on a Mix:

	:ceiling


On a PitchFlame:

	:pitch
	:neighbourhood			# to control raggedness
	:vol or :amp
	:pan

On Noize:

	:pitch
	:radius					# to control raggedness
	:vol or :amp
	:pan

	shape


On ClippedOscillator:

	:center
	:range
	:pitch, :freq or :duration
	:vol or :amp
	:pan

	shape


On an Oscillator that is being used as a control, typically:

	:pitch, :freq or :duration
	:multiplier
	:minValue
	:maxValue

	shape

On a RampStream that is being used as a control:

	:minValue
	:maxValue



Reference Summary
-------------------
I'm assuming that you are familiar enough with ruby to understand some of the shorthand I use here.


Textwise
	top of the class hierarchy.
	creates string representations of ruby objects

Tracer	< Textwise
	outputs strings to stderr (ie, the logfile)

	methods:
		tracing=true/false		# turn tracing on or off for this object
		me=string					# change object's name, for tracing purposes.

		trace( *obj )				# trace objects to stderr
		traceif( key, *obj )		# trace objects to stderr if trace key is set
		setTraceKey( key, bool )	# turn trace key on or off - used by traceif()

Setable	< Tracer
	implements the setable interface

	valueOf( obj )			# returns obj.nextValue if obj is a Generator, obj.out if obj is a Source, else returns obj
	set( key, value, trigger=false )		# performs some functionality according to a binding defined in the class
		# if trigger is true, use valueOf( value ) as the value
	trigger( key, value, trigger=true )	# same as set()

	
Generator 			ultimately, a subclass of Setable
	implements nextValue()

	this base class just holds a value in @current, and returns it

	methods:
		current
		current=
		nextValue()

	setable:
		:current,	value			# current=( value )
		:nextValue,	x				# nextValue() 					(value is ignored)


RandomFloat		< Generator
	new( minValue, maxValue )

	setable:
		:minValue, value
		:maxValue, value

similarly:
	RandomFreq, RandomHigh, RandomInteger


FromList		< Generator
	new( list )					# an array

	nextValue() randomly chooses a value from the list
		if @reTrigger is true, will return valueOf( value )

	setable:
		:list,	array		# sets the list being chosen from

NewFromList		< FromList
	like FromList, but will not choose the same value twice in a row (unless it has no choice)


FromWeightedList	< FromList
	new( list, weights )				# both are arrays

	nextValue() randomly chooses a value from the list, 
		but it uses the weights as a probability for each value in the list
		if @reTrigger is true, will return valueOf( value )

	setable:
		:weights,	array		# sets the weights

NewFromWeightedList	< FromWeightedList
	like FromWeightedList, but will not choose the same value twice in a row (unless it has no choice)


PickFromList	< FromList
	new( list )			# an array

	nextValue()		# will randomly choose a value from the list, and remove the value from the list
						# when the list is empty, it will start again with the original list
		if @reTrigger is true, will return valueOf( value )


ProbPair			< Generator
	new( a, b, prob )			# prob between 0.0 and 1.0 is the probability of choosing `a'

	attr_accessor :a, :b, :prob, :reTrigger

	nextValue() will return either a or b, with prob being the probability of selecting a
		if @reTrigger is true, will return valueOf( a ) or valueOf( b )

	setable:
		:a					@a=value
		:b					@b=value
		:prob				probA=value
		:reTrigger		@reTrigger=value


SequenceGenerator	< subclass of Generator
	new( array )		# an array of values

	nextValue()   will return the next value from the array.
		when it reaches the end of the array, will start again at the beginning
	see :triggerOnNext and :reTriggerOnNext, below.

	atEnd?()			returns true if the sequence if the most recent value returned was the last in the list

	:start		run start(), which sets the index to 0 (the first value will be the next on returned)
	:index		set index (0-based) for the next value to be returned
	:setsequence, array		the array becomes the sequence
	:sequence, array			the array becomes the sequence, and index=0
	:add, value					add a value to the end of the sequence

	:triggerOnNext, :reTriggerOnNext
		You can load up the sequence with Sources or Generators, in which case you may want to trigger
			the Source or Generator to get it's value.
		The logic used by SequenceGenerator in nextValue() is:

                value=@sequence[ @index ]
                @index+=1
                value=valueOf( value ) if @triggerOnNext
                value=valueOf( value ) if @reTriggerOnNext
                return value

		I have no idea why this is different from the other Generators, which only have :reTrigger



Tickable	<   subclass of Setable
	implements ticking

	methods:
		tick()				# you can tick() an object manually.
		ticks( *obj )		# will tick these snm objects
		tickedBy( tickable )		# this object will be ticked by tickable
		autoTick()			# this object magically ticks itself

		ctl, ctl=			# @ctl is a Hash.  every tick, do  trigger( key, value ) for each key value in @ctl.

	setable:
		:ctl,	[ key, value ]		# @ctl[ key ]=value
		:unctl, key					# remove key from @ctl

		:ticks, obj
		:tickedBy, obj

		:autoTick, x				autoTick()		ignores x



		:ticks


Shape < Tickable
	models a mathematical function with x in the range 0.0 - 1.0
	Shape models the function y=x (the identity function)
	In soundwave terms, it is a sawtooth waveform, going up


	f( x )				# the function being modelled
	value( x )			# returns f( x ), after bringing x into the valid range using modulo

	asText( rows, cols )		# ascii art representation of the shape


The following Shapes do not change:

	Sine
	Circle
	SemiCircle
	Quadrant
	DownQuadrant

The following Shapes have one argument, and one setable key:

	Square
		new( switchPoint )
		:switchPoint

	Triangle
		new( apex )
		:apex

	Pulse
		# a short triangle-shaped pulse at the start of the shape
		new( pulseLen )		# between 0.0 and 1.0
		:pulseLen

Some other shapes.  check out the source code, and use asText() to see what they look like:

	ADS			simple Attack Decay Sustain envelope shape.
		new( attack_x=0.1, decay_x=0.2, decay_y=0.8, sustain_x=0.8, sustain_y=nil )
		:attack_x, :decay_x, :decay_y, :sustain_x, :sustain_y

	Decay
		new( decay=0.5, noSteps=10 )
		:decay, :noSteps

	AttackDecay
		new( attack=0.1, decay=0.5, noSteps=10 )
		:noSteps, :attack, :decay

	Zag
		new( mid=0.10, hi=0.63 )
		:hi, :mid
	Zig
		new( hi=0.13, mid=0.26 )
		:hi, :mid
	ZigZag
		new( hi=0.33, lo=0.66 )
		:hi, :lo

	SharkTooth
		new( delta=0.55 )
		:delta

	Trapezium
		new( up=0.15, down=0.85 )
		:up, :down

	BoomShape
		new()			builds a random shape that has silence at the end

	BentSquare
		new( bend=0.1 )
		:bend

	SoftSquare
		new( xPeak=0.10, ySubPeak=0.90 )
		:xPeak, :ySubPeak, :makeGraph				# need to run makeGraph() after changing xPeak or ySubPeak

	TwinPeaksShape
		new( first=0.2, mid=0.0 )	# high point of first peak (0.0-0.5), and low point value in the valley
		:first, :mid, :build			# need to run build() after changing first or mid

	SimpleShape
		new( noPoints=10, upRate=0.6, peak=0.25, downRate=0.55, peakMode=:float )
		:noPoints, :upRate, :peak, :downRate, :peakMode

	NaturalShape
		new( hi=0.5, delta1=0.5, delta2=0.5 ) 		# hi 0.0-1.0, deltas -1.0, 1.0
		:hi, :delta1, :delta2

	OldNaturalEnvelopeShape
		new( attackRate=0.5, maxPoint=0.5, decayRate=0.5 )
		:maxPoint, :attackRate, :decayRate, :setup		
				# need to run setup() after changing maxPoint, attackRate, or decayRate

	Graph
		implements a Graph, such as you might draw on graph paper.
		it consists of a set x,y points, specified by an array of x values and an array of y values.
		if graphMode is :graph, the shape joins the x,y points using straight lines
		if graphMode is :step, the shape is a histogram

		new( graphMode=:graph )				# :graph or :step
		:x, array		# the set of x points (between 0.0 and 1.0)
		:y, array		# the set of y points (any float value)


	ShapeShifterShape	< Graph
		a Graph where the x values are evenly spaced on the interval 0.0, 1.0
		new( count=3 )

		setable:
			the key is an integer between 0 and count-1
			the value will specify the y value at the corresponding x value.

		eg

		make(
			ShapeShifterShape,
			[ 3 ],
			0,		0.0,
			1,		0.5,
			:ctl, 
				[
					2,
					make( Oscillator, [], :minValue, -1.0, :maxValue, 1.0, :duration, 3 )
				]
		 )


	SlapEnvelopeShape		< Graph
		a random shape

Source	< Tickable
	generates a signal, and makes it available as output

	methods
		signal()			# current value of the signal
		out()				# current output value, after applying amp()

	setable
		:amp
		:vol				# changes @amp in a non-linear fashion


StereoSource	< Source
	stereo source, additionally generates left and right signals

	methods
		lsignal(), rsignal()
		left(), right()			# after applying amp()

	setable
		:pan				# -1.0 means all on the left, 1.0 means all on the right, 0.0 is in the center.



Adder			< subclass of StereoSource
	adds the values of its inputs to produce its signal()
	by default, it will tick each input that is Tickable

	new( *input )				# alternatively, can specify a single argument which is an array
			each input can be a Source or a number

	methods
		input			the array @input
		[ i ]			@input[ i ]
		[ i ]=		@input[ i ]=

		add( *src )
		remove( *src )

		pitch=( value )		# apply pitch to each input that implements method pitch=()

	setable
		:pitch
		:input, array		# array of sources
		:add,		inp		# source
		:add,	array			# array of sources
		:remove,		inp		# source
		:remove,	array			# array of sources
		:tickInput, bool		# if true, Adder will tick each of its inputs

Multiplier < Adder
	multiplies the values of its inputs to produce its signal()
	
Mixer < Adder
	averages the values of its inputs to produce its signal()

Mix < Adder
	adds the values of its inputs, then applies an algorithm to keep the result within the range -1.0, 1.0

	:ceiling			# 0.5 - 1.0

CrossFader < Adder
	crossfades two inputs using a fader
	when fader is 0.0, first input is silent and second input is full volume
	when fader is 1.0, second input is silent and first input is full volume

	new( input0=Channel.new, input1=Channel.new, fader=1.0 )

	:fader, src		# sets the fader
	:tickSilentInput0, bool		# if false, does not tick input0 if fader is at 0.0 (true by default)
	:tickSilentInput, bool		# if false, does not tick input1 if fader is at 1.0 (true by default)


Channel	< subclass of StereoSource
	utility class that passes a signal through from an input.

		:tickInput, bool		# ticks input if true (the default)
		:pitchEnabled, bool	# if true (the default), will pass pitch=() through to the input
		:pitch, val				# sets pitch of the input if @pitchEnabled is true

	the value of this class is that it can stop certain behaviour from impacting on a source
		(for example ticking or pitch setting)

	eg

		make(
			Mix,
			[
				osc0,
				make( Channel, [ osc0 ], :tickInput, false, :pan, -0.5 ),	# prevent double-ticking
				make( Channel, [ osc1 ], :pitchEnabled, false )	# prevent pitch change
			],
			:ceiling, 0.2,
			:pitch, 128.0			# sets pitch of osc0, but not osc1
		 )

	Something else you can do with Channel is create silence,

		make( Channel, [ 0.0 ] )

	with 0.0 as the input, the output value will always be valueOf( 0.0 ), which is 0.0 (silence)

	Used in conjunction with CrossOverStream, it allows you to have sound alternating with silence:

		make(
			CrossOverStream,
			[
				make( 
					SequenceGenerator,
					[
						[
							soundSource,
							make( Channel, [ 0.0 ] )				# silence
						]
					]
				 ),
				make( RandomFloat, [ 3, 5 ] ),
				make( RandomFloat, [ 1, 2 ] )
			]
		 )


Factor	< Channel
	signal() is   2**input.out

	eg
		make(
			Oscillator,
			[],
			:ctl,
				[
					:freq,
					make(
						Multiplier,
						[
							256.0,
							make(

								Factor,
							#-------------

								[ make( Oscillator, [], :minValue, 0.0, :maxValue, 0.04. :freq, 15 ) ]	# vibrato
							 )
						]
				]
		 )


PitchBend	< Channel
	applies pitchbend to its input

	see explanation in tutorial, above.

	new( input=nil, multiplier=1.0, multiplierMode=:multiplier ) # :factor

	input's pitch is calculated as follows:
		multiplierPitch=valueOf( @multiplier )
		multiplierPitch=2**multiplierPitch if @multiplierMode==:factor
		pitchPitch=valueOf( @pitch )
		pitchPitch=2**pitchPitch if @pitchMode==:factor
		@input.pitch=multiplierPitch*pitchPitch

	setable:
		:pitch
		:pitchMode			by default @pitchMode=:multiplier.  can also be :factor
		:multiplier
		:multiplierMode


HiPassFilter	< subclass of StereoSource
	new( input=StereoSource.new(), cutoff=256.0 )

	:cutoff

similarly LoPassFilter

BandPassFilter
	new( input=StereoSource.new(), cutoff=256.0, radiusFactor=0.0 )

	can you believe, I forgot this one was even there!
	internally, it combines a HiPassFilter and a LoPassFilter
	it passes through frequencies between 
			@cutoff * 2**(-@radiusFactor)
		 and
			@cutoff * 2**@radiusFactor


Oscillator	< subclass of StereoSource
	new( shape=Sine.new )

	:freq
	:pitch			same as :freq
	:duration		duration = 1.0/freq
	:shape

	:tickShape		false by default
	:minValue		default is -1.0
	:maxValue		default is 1.0

	:multiplier				so can easily implement pitch bend
	:multiplierMode		:multiplier by default (can be :factor)
	:pitchMode				:multiplier by default (can be :factor)

	like PitchBend, it uses the following logic to calculate its actual frequency at each tick:

		 multiplierPitch=valueOf( @multiplier )
		 multiplierPitch=2**multiplierPitch if @multiplierMode==:factor
		 pitchPitch=valueOf( @pitch )
		 pitchPitch=2**pitchPitch if @pitchMode==:factor

		 @freq=multiplierPitch*pitchPitch



ClippedOscillator	< Oscillator
	experimental, see discussion in tutorial, above

	new( shape=Sine.new, center=0.0, range=1.0, mode=:add )


CrossOverStream	< subclass of StereoSource
	new( sourceGenerator, aloneDuration, crossOverDuration )
	:sourceGenerator, :aloneDuration, :crossOverDuration

Noize			< subclass of StereoSource
	new( shape=Sine.new, pitch=250.0, radius=0.1, radiusMode=:factor )
	:shape, :radius, :pitch

RampStream	< subclass of StereoSource
	new( minVal, maxVal, durationGen=RandomFloat.new( 1.0, 3.0 ), valueMode=:float )

	:minValue, :maxValue, :durationGenerator, :valueMode
	:startValue

PitchFlame	< subclass of RampStream
	new( pitch=250.0, neighbourhood=0.1 )

	:pitch, :neighbourhood



utility functions
-----------------

cloneHash( hash )
	creates a deep copy of hash.  also creates deep copy of any Arrays found

cloneArray( array )
	creates a deep copy of array.  also creates deep copy of any Hashes found

pick( array )
	randomly removes a value the array, and returns the value removed

randomFloat( minValue, maxValue, [tracemsg] )
randomFreq( minValue, maxValue, [tracemsg] )
randomHigh( minValue, maxValue, [tracemsg] )
randomInteger( minValue, maxValue, [tracemsg] )

chooseFrom( *list )
chooseWeighted( *list )		# list is a list of  value, weight pairs
	eg  shape=chooseWeighted( 
						Sine, 4, 
						Circle, 2, 
						Quadrant, 0.1
					 ).new





The Album
-----------

I wrote the script incrementally over a three week period.  I started from scratch with a very simple version (Hello World), and then went through about 40 intermediate versions until I ended up with the version you see in the release.

Once the final version of the script was completed, it took about three days to render the album, using a $300 laptop I bought second hand a few years ago.  The rendering happens on its own.  No hand-holding is necessary.

I didn't attempt to figure out what sound sources go well together, or what techniques work well together.  So the final format is pretty much a grab-bag of functions that create generic sounds, some functions that make random choices, and some utility functions for randomly generating "hints" and passing those hints through to the generic functions.

For hints I often use weighted lists (value, weight, .. ).  This means that when the script chooses from a list of possible values, each value has a different probability of being chosen.  I then construct the lists in such a way that only one or two choices have a good probability of being chosen, but the weights change each time the script is run.

This way, each track will tend to have it's own character or flavour, different from the other tracks.

It also means that if the track is based on CrossFader or CrossOverStream, with more than one "segment", then I can ensure a good level of contrast between each of the segments.

If you study the code, you will notice that in the end, it only uses the classes I have described in this module,
 but I have cheated a little when it comes to making choices and passing around the hints.  The point is that you
 could rewrite the script to only use information I have given in this module, if you write your own utility functions.

Where I have used [:spec, ... ], you can substitute make( ... ) and it should still work.  You may need to write
 your own utility functions for choosing shapes.  The function makespec() will build an object from a [:spec, .. ]

I'll explain this stuff in future modules.



In the next module, I will introduce sound events, and start playing with melodies and non-musical scales.


